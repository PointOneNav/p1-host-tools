#!/usr/bin/env python

import os
from pathlib import Path

import paramiko

SSH_KEY_PATH = os.environ.get('HITL_SSH_KEY_PATH', str(Path.home() / '.ssh/id_ed25519'))
SSH_USERNAME = os.environ.get('HITL_SSH_USERNAME', 'pointone')
# SSH_ADDRESS = '192.168.8.172'
SSH_ADDRESS = 'jenkins-hitl1'

RUNNER_CMD = "ls /bin"


def _check_process_exit(ssh_client, ssh_channel) -> bool:
    if ssh_client is not None and ssh_channel is not None:
        if not ssh_channel.exit_status_ready():
            print('FE process still running after shutdown timeout.')
            return False
        elif not ssh_channel.recv_ready():
            print("Missing return code string.")
            return False
        else:
            console_output = ''
            # Even if process is ended, may need multiple reads.
            while True:
                read_str = ssh_channel.recv(10240).decode(errors='ignore')
                if len(read_str) == 0:
                    break
                console_output += read_str

            lines = console_output.split(':')
            try:
                ret_code = int(lines[-1])
                # return codes > 128 indicate a signal triggered the termination (subtract 128 for the error code to
                # get the corresponding signal). Codes 1,2,9,10,12-15 are signals that may be generated by external
                # sources (SIGHUP, SIGKILL, etc.) so they don't indicate an internal failure.
                # https://man7.org/linux/man-pages/man7/signal.7.html
                # https://faculty.cs.niu.edu/~hutchins/csci480/signals.htm
                if ret_code in [0, 129, 130, 137, 138, 140, 141, 142, 143]:
                    print(f"FE process exited successfully with code: {ret_code}")
                    return True
                else:
                    print(f"FE process exited with error code: {ret_code}")
                    print("Process final output:\n" + ('=' * 80) + '\n' + console_output + ('=' * 80))
                    return False
            except ValueError as e:
                print(f"Could not parse return code: {e}")
                return False
    print(f"FE process wasn't started.")
    return True


pkey = paramiko.Ed25519Key.from_private_key_file(SSH_KEY_PATH)

# Set up SSH automation tool.
ssh_client = paramiko.SSHClient()
ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
print(f'Attempting to connect to TCP address {SSH_ADDRESS}')
try:
    ssh_client.connect(SSH_ADDRESS, username=SSH_USERNAME, pkey=pkey, timeout=5.0)
except Exception as e:
    print("Failed to connect to TCP address %s: %s" % (SSH_ADDRESS, str(e)))
    exit(1)


# Check for successful connection.
transport = ssh_client.get_transport()
if transport is None or not transport.is_active():
    print('Failed to connect to TCP address.')
    exit(1)

# Run bootstrap script.
channel = transport.open_session()

print('Starting engine.')

################# Step 2: Run Engine #####################

# From https://docs.paramiko.org/en/stable/api/channel.html:
# Because SSH2 has a windowing kind of flow control, if you stop reading data from a Channel and its buffer
# fills up, the server will be unable to send you any more data until you read some of it. To handle this, all
# output is passed into tail to avoid needing to continuously read data over the SSH connection. This creates an
# issue where the return code of this call is the exit code of `tail`. Using `PIPESTATUS` gets the exit code of
# the FE process dumped to stdout.
#
# On top of that, some platforms use sh instead of bash as their default shell. That would not properly
# interpret this command. To get around this, we explicitly run the command in bash.
BUFFER_OUTPUT_AND_EXIT_CODE = r' 2>&1 | tail -n 100; echo Exit Code:${PIPESTATUS[0]}'
channel.set_combine_stderr(True)
full_bash_cmd = RUNNER_CMD + BUFFER_OUTPUT_AND_EXIT_CODE
full_run_cmd = f"bash -c '{full_bash_cmd}'"
print(full_run_cmd.replace('\n', '\\n'))
channel.exec_command(full_run_cmd)

channel.recv_exit_status()

_check_process_exit(ssh_client, channel)
